---
phase: 08-post-purchase-features
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/services/api.ts
  - frontend/src/features/will/store/useWillStore.ts
  - frontend/src/features/will/hooks/useAutoSave.ts
  - frontend/src/features/will/components/WillWizard.tsx
  - frontend/src/features/will/types/will.ts
autonomous: true

must_haves:
  truths:
    - "Form section data is auto-saved to backend after debounce"
    - "markSectionComplete and setCurrentSection sync to backend DB"
    - "Zustand store can be hydrated from server will data"
    - "snakeToCamel utility converts DB snake_case to frontend camelCase"
  artifacts:
    - path: "frontend/src/features/will/hooks/useAutoSave.ts"
      provides: "Debounced auto-save hook with flush capability"
      min_lines: 25
    - path: "frontend/src/features/will/store/useWillStore.ts"
      provides: "loadFromServer action for will hydration from API"
      contains: "loadFromServer"
    - path: "frontend/src/services/api.ts"
      provides: "listWills, updateCurrentSection, regenerateWill API functions"
      contains: "updateCurrentSection"
  key_links:
    - from: "frontend/src/features/will/components/WillWizard.tsx"
      to: "frontend/src/services/api.ts"
      via: "markSectionComplete and updateCurrentSection calls"
      pattern: "markSectionComplete|updateCurrentSection"
    - from: "frontend/src/features/will/hooks/useAutoSave.ts"
      to: "frontend/src/services/api.ts"
      via: "updateWillSection in debounced callback"
      pattern: "updateWillSection"
---

<objective>
Close the Zustand-to-DB sync gap and add auto-save for form sections. Add `loadFromServer` store action for resume hydration and new API client functions.

Purpose: This is the critical infrastructure that makes save/resume work. Without it, progress only exists in localStorage and is lost across devices/browsers.
Output: useAutoSave hook, snakeToCamel utility, loadFromServer action, synced WillWizard, new API functions.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/08-post-purchase-features/08-01-SUMMARY.md
@frontend/src/services/api.ts
@frontend/src/features/will/store/useWillStore.ts
@frontend/src/features/will/components/WillWizard.tsx
@frontend/src/features/will/types/will.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: API functions, snakeToCamel utility, and WillResponse update</name>
  <files>
    frontend/src/services/api.ts
    frontend/src/features/will/types/will.ts
  </files>
  <action>
    **1. Update WillResponse interface** in `frontend/src/services/api.ts`:
    Add these fields to the existing `WillResponse` interface:
    - `version: number`
    - `current_section: string`
    - `paid_at: string | null`
    Also add the complex section fields that are missing (needed for resume hydration):
    - `trust_provisions: Record<string, unknown>`
    - `usufruct: Record<string, unknown>`
    - `business_assets: Record<string, unknown>[]`
    - `joint_will: Record<string, unknown>`
    - `scenarios: string[]`

    **2. Add new API functions** at end of `frontend/src/services/api.ts`:

    a) `listWills()` — GET /wills, returns `Promise<WillResponse[]>`
    b) `updateCurrentSection(willId: string, section: string)` — PATCH /wills/{willId}/current-section, body `{ current_section: section }`, returns `Promise<WillResponse>`
    c) `regenerateWill(willId: string)` — POST /wills/{willId}/regenerate, returns `Promise<{ download_token: string; version: number }>`

    **3. Add `snakeToCamel` utility** in `frontend/src/services/api.ts` (near top, after imports, exported):
    ```typescript
    /** Convert snake_case keys to camelCase for frontend consumption */
    export function snakeToCamel(obj: Record<string, unknown>): Record<string, unknown> {
      const result: Record<string, unknown> = {}
      for (const [key, value] of Object.entries(obj)) {
        const camelKey = key.replace(/_([a-z])/g, (_, c) => c.toUpperCase())
        result[camelKey] = value
      }
      return result
    }
    ```

    **4. Update WillActions interface** in `frontend/src/features/will/types/will.ts`:
    Add `loadFromServer: (will: WillResponse) => void` to the WillActions interface.
    Import `WillResponse` from `'../../../services/api'` at the top of the types file (or use inline type).

    Actually, to avoid circular dependency, define the action type inline:
    ```typescript
    loadFromServer: (will: Record<string, unknown>) => void
    ```
    The actual implementation in the store will use the concrete WillResponse type.
  </action>
  <verify>
    Run `cd /opt/lampp/htdocs/wdi/frontend && npx tsc --noEmit 2>&1 | head -20` — should have no errors related to api.ts or will.ts.
  </verify>
  <done>WillResponse has version/current_section/paid_at + complex fields. API has listWills, updateCurrentSection, regenerateWill functions. snakeToCamel utility exported. WillActions has loadFromServer.</done>
</task>

<task type="auto">
  <name>Task 2: loadFromServer store action, useAutoSave hook, and WillWizard sync</name>
  <files>
    frontend/src/features/will/store/useWillStore.ts
    frontend/src/features/will/hooks/useAutoSave.ts
    frontend/src/features/will/components/WillWizard.tsx
  </files>
  <action>
    **1. Add `loadFromServer` action** to `useWillStore.ts`:
    Import `snakeToCamel` from `'../../../services/api'` and `WillResponse` type.

    Add inside the `immer((set) => ({` block, after `resetWill`:
    ```typescript
    loadFromServer: (will: WillResponse) =>
      set((state) => {
        state.willId = will.id
        state.testator = snakeToCamel(will.testator || {}) as Partial<Testator>
        state.marital = snakeToCamel(will.marital || {}) as Partial<MaritalInfo>
        state.beneficiaries = (will.beneficiaries || []).map(b => snakeToCamel(b) as Beneficiary)
        state.assets = (will.assets || []).map(a => snakeToCamel(a) as Asset)
        state.guardians = (will.guardians || []).map(g => snakeToCamel(g) as Guardian)
        state.executor = snakeToCamel(will.executor || {}) as Partial<ExecutorInfo>
        state.bequests = (will.bequests || []).map(b => snakeToCamel(b) as Bequest)
        state.residue = snakeToCamel(will.residue || {}) as Partial<ResidueInfo>
        state.trustProvisions = snakeToCamel(will.trust_provisions || {}) as Partial<TrustProvisions>
        state.usufruct = snakeToCamel(will.usufruct || {}) as Partial<UsufructProvision>
        state.businessAssets = (will.business_assets || []).map(b => snakeToCamel(b) as BusinessAssetDetail)
        state.jointWill = snakeToCamel(will.joint_will || {}) as Partial<JointWillConfig>
        state.scenarios = (will.scenarios || []) as ComplexScenario[]
        state.sectionsComplete = will.sections_complete || {}
        state.currentSection = (will.current_section || 'personal') as WillSection
      }),
    ```

    **2. Create `useAutoSave` hook** at `frontend/src/features/will/hooks/useAutoSave.ts`:
    ```typescript
    import { useEffect, useRef, useCallback } from 'react'
    import { updateWillSection } from '../../../services/api'

    /**
     * Debounced auto-save hook for form-based will sections.
     * Saves section data to the backend after a period of inactivity.
     * Returns a `flush` function to trigger an immediate save (e.g., before navigation).
     */
    export function useAutoSave(
      willId: string | null,
      section: string,
      data: Record<string, unknown>,
      delay = 2000,
    ) {
      const timeoutRef = useRef<ReturnType<typeof setTimeout>>()
      const dataRef = useRef(data)
      const inflightRef = useRef<AbortController | null>(null)
      dataRef.current = data

      useEffect(() => {
        if (!willId) return

        clearTimeout(timeoutRef.current)
        timeoutRef.current = setTimeout(async () => {
          try {
            // Abort any previous in-flight request
            inflightRef.current?.abort()
            inflightRef.current = new AbortController()
            await updateWillSection(willId, section, dataRef.current)
          } catch (err) {
            if (err instanceof Error && err.name !== 'AbortError') {
              console.error(`Auto-save failed for ${section}:`, err)
            }
          }
        }, delay)

        return () => clearTimeout(timeoutRef.current)
      }, [willId, section, JSON.stringify(data), delay])

      const flush = useCallback(async () => {
        clearTimeout(timeoutRef.current)
        if (willId) {
          try {
            await updateWillSection(willId, section, dataRef.current)
          } catch (err) {
            console.error(`Auto-save flush failed for ${section}:`, err)
          }
        }
      }, [willId, section])

      return { flush }
    }
    ```

    **3. Update WillWizard.tsx** to sync markSectionComplete and setCurrentSection to backend:

    a) Import `markSectionComplete as markSectionCompleteApi, updateCurrentSection` from `'../../../services/api.ts'`.

    b) In `handleNextSection` callback, AFTER calling the Zustand `markSectionComplete(currentSection)`, add a fire-and-forget backend sync:
    ```typescript
    // Sync to backend (fire-and-forget)
    if (willId) {
      markSectionCompleteApi(willId, currentSection).catch((err) =>
        console.error('Failed to sync section complete:', err)
      )
    }
    ```

    c) When `setCurrentSection` is called to advance (inside `handleNextSection`, after computing nextIndex), also fire-and-forget sync the new section:
    ```typescript
    const nextSection = sections[nextIndex].key
    setCurrentSection(nextSection)
    if (willId) {
      updateCurrentSection(willId, nextSection).catch((err) =>
        console.error('Failed to sync current section:', err)
      )
    }
    ```

    d) In `handleNavigateToSection` (used by ReviewChat to jump back), also sync:
    ```typescript
    const handleNavigateToSection = useCallback(
      (section: WillSection) => {
        setCurrentSection(section)
        if (willId) {
          updateCurrentSection(willId, section).catch((err) =>
            console.error('Failed to sync current section:', err)
          )
        }
      },
      [setCurrentSection, willId],
    )
    ```

    e) Rename the imported Zustand `markSectionComplete` selector to avoid collision with the API import. Use:
    ```typescript
    const markSectionCompleteLocal = useWillStore((s) => s.markSectionComplete)
    ```
    Then use `markSectionCompleteLocal` in `handleNextSection` instead of `markSectionComplete`.

    **IMPORTANT**: The `toSnakeCase` utility that already exists in WillWizard.tsx stays as-is. It is used for form data serialization. The new `snakeToCamel` in api.ts is the inverse for deserialization.
  </action>
  <verify>
    Run `cd /opt/lampp/htdocs/wdi/frontend && npx tsc --noEmit 2>&1 | head -20` — should compile without errors.
    Check that `useAutoSave.ts` exists and exports the hook.
    Check that `useWillStore.ts` has `loadFromServer` action.
    Check that `WillWizard.tsx` imports and calls `markSectionCompleteApi` and `updateCurrentSection`.
  </verify>
  <done>Zustand store has loadFromServer for hydration from API. useAutoSave hook exists with debounce + flush. WillWizard syncs markSectionComplete and setCurrentSection to backend DB on every navigation event.</done>
</task>

</tasks>

<verification>
1. `snakeToCamel` utility converts `{first_name: "x"}` to `{firstName: "x"}`
2. `loadFromServer` action populates all Zustand fields from WillResponse
3. `useAutoSave` hook debounces saves and provides flush for immediate save
4. `WillWizard.handleNextSection` calls both Zustand + backend markSectionComplete
5. `WillWizard.setCurrentSection` calls backend updateCurrentSection
6. Frontend compiles without TypeScript errors
</verification>

<success_criteria>
- useAutoSave hook created with debounce + flush pattern
- loadFromServer hydrates Zustand from server WillResponse
- snakeToCamel converts all snake_case keys to camelCase
- WillWizard syncs section completion and current section to backend
- New API functions: listWills, updateCurrentSection, regenerateWill
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-post-purchase-features/08-02-SUMMARY.md`
</output>
