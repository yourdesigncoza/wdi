---
phase: 06-document-generation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - backend/app/services/document_service.py
  - backend/app/schemas/document.py
autonomous: true

must_haves:
  truths:
    - "Clause assembly pipeline produces ordered rendered clause list from will JSONB data"
    - "Variable extraction maps will section data to clause template variables with safe defaults"
    - "PDF generation runs in thread executor (does not block async event loop)"
    - "Preview PDFs include watermark, final PDFs do not"
  artifacts:
    - path: "backend/app/services/document_service.py"
      provides: "DocumentGenerationService with clause assembly, variable extraction, and PDF generation"
      min_lines: 120
    - path: "backend/app/schemas/document.py"
      provides: "Pydantic schemas for document generation requests/responses"
      min_lines: 15
  key_links:
    - from: "backend/app/services/document_service.py"
      to: "backend/app/services/clause_library.py"
      via: "ClauseLibraryService for clause retrieval and rendering"
      pattern: "ClauseLibraryService"
    - from: "backend/app/services/document_service.py"
      to: "backend/app/services/will_service.py"
      via: "WillService for will retrieval with ownership check"
      pattern: "WillService"
    - from: "backend/app/services/document_service.py"
      to: "backend/app/templates/will/base.html"
      via: "Jinja2 FileSystemLoader template rendering"
      pattern: "FileSystemLoader|get_template"
---

<objective>
Build the DocumentGenerationService that assembles clauses from will JSONB data, renders them into the HTML template, and generates PDF via WeasyPrint in a thread pool.

Purpose: This is the core backend logic that transforms collected will data into a PDF document. It bridges the clause library, will data, and HTML templates.
Output: document_service.py (service) + document.py (schemas)
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-document-generation/06-RESEARCH.md
@.planning/phases/06-document-generation/06-01-SUMMARY.md
@backend/app/services/clause_library.py
@backend/app/services/will_service.py
@backend/app/models/will.py
@backend/app/models/clause.py
@backend/scripts/seed_clauses.py (clause codes and variable schemas)
@backend/app/config.py
@backend/app/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create document schemas and DocumentGenerationService with clause assembly</name>
  <files>
    backend/app/schemas/document.py
    backend/app/services/document_service.py
  </files>
  <action>
    **schemas/document.py:**
    Create Pydantic models:
    ```python
    class GeneratePreviewRequest(BaseModel):
        disclaimer_acknowledged: bool  # Must be True to generate

    class DocumentInfo(BaseModel):
        will_id: str
        document_reference: str  # WC-{short_id}-{timestamp}
        generated_at: str
        is_preview: bool
        page_count: int | None = None
    ```

    **services/document_service.py:**
    Core service with these components:

    1. **Module-level setup:**
       - `TEMPLATE_DIR = Path(__file__).parent.parent / "templates" / "will"`
       - `_pdf_executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="pdf-gen")`
       - `_doc_jinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)), autoescape=True)`
       - Import: `asyncio, logging, uuid, datetime, Path, ThreadPoolExecutor, Environment, FileSystemLoader, HTML (from weasyprint), AsyncSession, Depends`
       - Import: `ClauseLibraryService, WillService, Will, Clause, ClauseCategory, WillType, get_session`

    2. **CLAUSE_ORDER constant** -- defines the assembly pipeline order:
       ```python
       CLAUSE_ORDER = [
           {"code": "REVOC-01", "section": None, "condition": "always"},
           {"code": "JOINT-01", "section": "joint_will", "condition": "scenario:joint_will"},
           {"code": "EXEC-01", "section": "executor", "condition": "always"},
           {"code": "EXEC-02", "section": "executor", "condition": "has:executor.backup_name"},
           {"code": "BENEF-01", "section": "bequests", "condition": "each:bequests"},
           {"code": "GUARD-01", "section": "guardians", "condition": "has_items:guardians"},
           {"code": "TRUST-01", "section": "trust_provisions", "condition": "scenario:testamentary_trust"},
           {"code": "USUF-01", "section": "usufruct", "condition": "scenario:usufruct"},
           {"code": "BUS-01", "section": "business_assets", "condition": "each:business_assets:cc"},
           {"code": "BUS-02", "section": "business_assets", "condition": "each:business_assets:company"},
           {"code": "BENEF-02", "section": "residue", "condition": "always"},
       ]
       ```
       Note: WIT-01 is NOT in CLAUSE_ORDER because the signature page is a separate HTML template, not a clause in the body.

    3. **`extract_variables(will: Will, clause_code: str, item: dict | None = None) -> dict`** -- static method or module function:
       Per-clause variable extraction from will JSONB columns. For each clause code, map will data to template variables. Use safe defaults -- if a field is missing, use `"[To be completed]"` placeholder (not empty string, not raise). Example:
       ```python
       def _extract_variables(will: Will, clause_code: str, item: dict | None = None) -> dict:
           testator_name = f"{will.testator.get('first_name', '')} {will.testator.get('last_name', '')}".strip()

           extractors = {
               "REVOC-01": lambda: {
                   "testator_full_name": testator_name or "[To be completed]",
                   "testator_id_number": will.testator.get("id_number", "[To be completed]"),
               },
               "EXEC-01": lambda: {
                   "executor_name": will.executor.get("name", "[To be completed]"),
                   "executor_id_number": will.executor.get("id_number", "[To be completed]"),
                   "executor_address": will.executor.get("address", "[To be completed]"),
               },
               "EXEC-02": lambda: {
                   "executor_name": will.executor.get("name", "[To be completed]"),
                   "alternate_executor_name": will.executor.get("backup_name", "[To be completed]"),
                   "alternate_executor_id_number": will.executor.get("backup_id_number", "[To be completed]"),
                   "alternate_executor_address": will.executor.get("backup_address", "[To be completed]"),
               },
               "BENEF-01": lambda: {
                   "asset_description": (item or {}).get("asset_description", "[To be completed]"),
                   "beneficiary_name": (item or {}).get("beneficiary_name", "[To be completed]"),
                   "beneficiary_id_number": (item or {}).get("beneficiary_id_number", "[To be completed]"),
                   "alternate_beneficiary_name": (item or {}).get("alternate_beneficiary_name", ""),
               },
               "BENEF-02": lambda: {
                   "residue_beneficiary_name": will.residue.get("beneficiary_name", "[To be completed]"),
                   "residue_beneficiary_id_number": will.residue.get("beneficiary_id_number", "[To be completed]"),
               },
               "GUARD-01": lambda: {
                   "guardian_name": will.guardians[0].get("name", "[To be completed]") if will.guardians else "[To be completed]",
                   "guardian_id_number": will.guardians[0].get("id_number", "[To be completed]") if will.guardians else "[To be completed]",
                   "guardian_address": will.guardians[0].get("address", "[To be completed]") if will.guardians else "[To be completed]",
                   "children_names": ", ".join(g.get("child_name", "") for g in will.guardians if g.get("child_name")),
               },
               "TRUST-01": lambda: {
                   "children_names": will.trust_provisions.get("beneficiary_names", "[To be completed]"),
                   "trust_name": will.trust_provisions.get("trust_name", "[To be completed]"),
                   "trustee_names": will.trust_provisions.get("trustee_names", "[To be completed]"),
                   "vesting_age": will.trust_provisions.get("vesting_age", 18),
               },
               "USUF-01": lambda: {
                   "usufructuary_name": will.usufruct.get("usufructuary_name", "[To be completed]"),
                   "usufructuary_id_number": will.usufruct.get("usufructuary_id_number", "[To be completed]"),
                   "property_description": will.usufruct.get("property_description", "[To be completed]"),
                   "bare_dominium_holders": will.usufruct.get("bare_dominium_holders", "[To be completed]"),
               },
               "BUS-01": lambda: {
                   "percentage_held": (item or {}).get("percentage_held", "[To be completed]"),
                   "business_name": (item or {}).get("business_name", "[To be completed]"),
                   "registration_number": (item or {}).get("registration_number", "[To be completed]"),
                   "heir_name": (item or {}).get("heir_name", "[To be completed]"),
               },
               "BUS-02": lambda: {
                   "percentage_held": (item or {}).get("percentage_held", "[To be completed]"),
                   "business_name": (item or {}).get("business_name", "[To be completed]"),
                   "registration_number": (item or {}).get("registration_number", "[To be completed]"),
                   "heir_name": (item or {}).get("heir_name", "[To be completed]"),
               },
               "JOINT-01": lambda: {
                   "testator_1_name": testator_name or "[To be completed]",
                   "testator_1_id": will.testator.get("id_number", "[To be completed]"),
                   "testator_2_name": will.joint_will.get("spouse_name", "[To be completed]"),
                   "testator_2_id": will.joint_will.get("spouse_id_number", "[To be completed]"),
               },
           }
           extractor = extractors.get(clause_code)
           return extractor() if extractor else {}
       ```

    4. **`_should_include_clause(will: Will, entry: dict) -> bool | list`** -- evaluates the condition:
       - `"always"` -> True
       - `"scenario:X"` -> X in will.scenarios
       - `"has:field.subfield"` -> truthy nested check on will data
       - `"has_items:field"` -> len(getattr(will, field, [])) > 0
       - `"each:field"` -> returns list of items from will.field (BENEF-01 per bequest)
       - `"each:field:type"` -> filter items by `business_type` matching type ("cc" or "company")

    5. **`DocumentGenerationService` class:**
       - `__init__(self, session: AsyncSession)` -- creates WillService and ClauseLibraryService instances
       - `async def generate_preview(self, will_id, user_id) -> bytes` -- calls `_generate(will, is_preview=True)`
       - `async def generate_final(self, will_id, user_id) -> bytes` -- calls `_generate(will, is_preview=False)` (for Phase 7)
       - `async def _generate(self, will: Will, is_preview: bool) -> bytes`:
         1. Assemble clauses via `_assemble_clauses(will)`
         2. Build template context dict: testator_name, document_reference (`WC-{will.id.hex[:8].upper()}-{timestamp}`), signing_year, clauses list, is_preview
         3. Render HTML via `_doc_jinja_env.get_template("base.html").render(**context)`
         4. Generate PDF in executor: `await loop.run_in_executor(_pdf_executor, _render_pdf_sync, html_string)`
         5. Optionally update will status to "generated" if not preview (skip for now -- Phase 7)
         6. Return pdf_bytes
       - `async def _assemble_clauses(self, will: Will) -> list[dict]`:
         For each entry in CLAUSE_ORDER:
           - Check condition via `_should_include_clause`
           - If truthy, fetch clause from DB via `clause_svc.get_clause_by_code(entry["code"])`
           - Extract variables via `_extract_variables(will, code, item)`
           - Render clause text. Use try/except around render_clause -- if UndefinedError, use clause.template_text raw with "[MISSING: variable]" note logged
           - Append to assembled list with `number` (auto-incrementing), `name`, `rendered_text`, `sub_clauses` (empty for now)
         Return list

    6. **`_render_pdf_sync(html_string: str) -> bytes`** -- module-level function:
       ```python
       def _render_pdf_sync(html_string: str) -> bytes:
           return HTML(string=html_string, base_url=str(TEMPLATE_DIR)).write_pdf()
       ```
       The CSS is embedded in the HTML template, so no separate stylesheet needed.

    7. **DI factory function:**
       ```python
       def get_document_service(session: AsyncSession = Depends(get_session)) -> DocumentGenerationService:
           return DocumentGenerationService(session=session)
       ```
  </action>
  <verify>
    `python -c "from app.services.document_service import DocumentGenerationService; print('OK')"` from backend/ dir.
    `python -c "from app.schemas.document import GeneratePreviewRequest; print('OK')"` from backend/ dir.
    Grep: `grep "run_in_executor" backend/app/services/document_service.py` -- should match.
    Grep: `grep "ClauseLibraryService" backend/app/services/document_service.py` -- should match.
  </verify>
  <done>DocumentGenerationService exists with clause assembly pipeline, variable extraction with safe defaults, Jinja2 HTML rendering, and WeasyPrint PDF generation in thread executor. DI factory function ready for API endpoint injection.</done>
</task>

</tasks>

<verification>
1. `from app.services.document_service import DocumentGenerationService, get_document_service` imports cleanly
2. `from app.schemas.document import GeneratePreviewRequest, DocumentInfo` imports cleanly
3. Service uses run_in_executor for PDF generation (grep confirms)
4. Service uses ClauseLibraryService for clause retrieval (grep confirms)
5. CLAUSE_ORDER covers all 12 clause codes from seed_clauses.py (minus WIT-01 which is in signature page)
6. Variable extraction handles missing fields with "[To be completed]" defaults
</verification>

<success_criteria>
DocumentGenerationService can assemble clauses from will data, render HTML template, and produce PDF bytes asynchronously. All clause codes mapped. Missing data handled gracefully with placeholder text.
</success_criteria>

<output>
After completion, create `.planning/phases/06-document-generation/06-02-SUMMARY.md`
</output>
