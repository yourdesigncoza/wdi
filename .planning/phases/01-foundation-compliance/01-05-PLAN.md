---
phase: 01-foundation-compliance
plan: 05
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - backend/app/services/upl_filter.py
  - backend/app/api/ai.py
  - backend/app/schemas/ai.py
  - backend/tests/test_upl_filter.py
autonomous: true

must_haves:
  truths:
    - "AI outputs containing legal advice patterns are filtered"
    - "Filtered content replaced with approved clause text or fallback message"
    - "Complex scenarios trigger attorney referral response"
    - "All filter activations logged to audit trail"
  artifacts:
    - path: "backend/app/services/upl_filter.py"
      provides: "UPLFilterService"
      contains: "class UPLFilterService"
    - path: "backend/app/api/ai.py"
      provides: "AI filter test endpoint"
      exports: ["router"]
    - path: "backend/tests/test_upl_filter.py"
      provides: "UPL filter tests"
      contains: "test_"
  key_links:
    - from: "backend/app/services/upl_filter.py"
      to: "backend/app/services/clause_library.py"
      via: "clause replacement"
      pattern: "clause_service\\.get_clause"
    - from: "backend/app/services/upl_filter.py"
      to: "backend/app/services/audit_service.py"
      via: "filter logging"
      pattern: "audit_service\\.log_event"
---

<objective>
Create UPL (Unauthorized Practice of Law) filter service to prevent AI from providing legal advice, replacing with approved clause text or attorney referral.

Purpose: Architectural constraint ensuring all legal text comes from clause library, not AI generation
Output: UPLFilterService with pattern matching, clause replacement, and comprehensive logging
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-compliance/01-RESEARCH.md
@.planning/phases/01-foundation-compliance/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: UPL filter service with pattern matching</name>
  <files>
    backend/app/services/upl_filter.py
  </files>
  <action>
    Create UPLFilterService following RESEARCH.md patterns:

    **FilterAction enum:** ALLOW, REPLACE, BLOCK, REFER

    **FilterResult dataclass:**
    - action: FilterAction
    - original_text: str
    - filtered_text: str
    - clause_code: str | None (if replaced)
    - reason: str | None
    - patterns_matched: list[str] (for logging)

    **UPLFilterService class:**
    - __init__(clause_service, audit_service)

    **ADVICE_PATTERNS** (compile as regex, case-insensitive):
    - r"you should\s+(?:definitely\s+)?(?:include|add|create|make)"
    - r"I (?:recommend|advise|suggest)\s+(?:that\s+)?you"
    - r"the best (?:way|approach|option)\s+(?:is|would be)"
    - r"you (?:must|need to|have to)\s+(?:do|include|specify)"
    - r"legally,?\s+you\s+(?:should|must|need)"
    - r"in my (?:legal\s+)?opinion"
    - r"as your (?:lawyer|attorney|legal advisor)"

    **ATTORNEY_REQUIRED** (trigger immediate referral):
    - r"tax\s+(?:implications|consequences|planning)"
    - r"estate\s+duty"
    - r"business\s+(?:succession|valuation)"
    - r"offshore\s+(?:assets|trust)"
    - r"disputed\s+(?:estate|inheritance|will)"
    - r"litigation|court\s+order|legal\s+dispute"

    **FALLBACK_MESSAGE:**
    "For this specific situation, we recommend consulting with a qualified South African attorney who can provide personalized legal advice."

    **filter_output(text: str, context: dict) -> FilterResult:**
    1. Check ATTORNEY_REQUIRED patterns first -> return REFER with FALLBACK_MESSAGE
    2. Check ADVICE_PATTERNS -> try to find replacement clause based on context
    3. If clause found -> return REPLACE with clause text
    4. If no clause -> return BLOCK with FALLBACK_MESSAGE
    5. If no patterns matched -> return ALLOW with original text
    6. Log all non-ALLOW results to audit_service

    **Context dict expected keys:**
    - category: ClauseCategory (which section being discussed)
    - will_type: WillType (basic, trust, etc.)
    - session_id: str (for audit correlation)

    **_find_replacement_clause(context: dict) -> Clause | None:**
    - Use clause_service.get_clauses_by_category to find appropriate clause
    - Return first match or None
  </action>
  <verify>
    python -c "from app.services.upl_filter import UPLFilterService, FilterAction; print('UPLFilterService OK')"
  </verify>
  <done>UPLFilterService with pattern detection, clause replacement, and audit logging</done>
</task>

<task type="auto">
  <name>Task 2: AI filter test endpoint and schemas</name>
  <files>
    backend/app/api/ai.py
    backend/app/schemas/ai.py
  </files>
  <action>
    Create test endpoint for UPL filter:

    **schemas/ai.py:**
    - FilterTestRequest: text (str), context (dict with optional category, will_type)
    - FilterTestResponse: action (str), original_text (str), filtered_text (str), clause_code (str | None), reason (str | None), patterns_matched (list[str])

    **api/ai.py:**
    - POST /api/ai/filter-test - Test UPL filter with provided text
      - Accepts FilterTestRequest
      - Returns FilterTestResponse
      - Requires consent
      - Logs test to audit trail (event_type: upl_filter_test)

    This endpoint is for development/testing purposes. In production (Phase 3+), the filter will be integrated into the conversation flow automatically.

    Add router to main.py.
  </action>
  <verify>
    curl -X POST http://localhost:8000/api/ai/filter-test \
      -H "Content-Type: application/json" \
      -b cookies.txt \
      -d '{"text": "You should definitely include a trust clause", "context": {"category": "trust"}}'
  </verify>
  <done>Filter test endpoint accepts text and returns filter result</done>
</task>

<task type="auto">
  <name>Task 3: UPL filter unit tests</name>
  <files>
    backend/tests/__init__.py
    backend/tests/conftest.py
    backend/tests/test_upl_filter.py
  </files>
  <action>
    Create unit tests for UPL filter:

    **conftest.py:**
    - Mock clause_service fixture returning sample clauses
    - Mock audit_service fixture (no-op logging)
    - UPLFilterService fixture with mocked dependencies

    **test_upl_filter.py:**

    Test ALLOW cases:
    - "The executor manages the estate." -> ALLOW (informational)
    - "A will must be signed by two witnesses." -> ALLOW (factual)
    - "You can list multiple beneficiaries." -> ALLOW (no advice pattern)

    Test REPLACE cases:
    - "You should include a residuary clause." -> REPLACE (with clause)
    - "I recommend you appoint an executor." -> REPLACE (with EXEC-01)

    Test BLOCK cases:
    - "You must specify exact percentages." -> BLOCK (advice, no matching clause in mock)
    - "The best approach is to create a trust." -> BLOCK (advice pattern)

    Test REFER cases:
    - "Consider the tax implications of this bequest." -> REFER (attorney required)
    - "This may trigger estate duty concerns." -> REFER
    - "For offshore assets, you should..." -> REFER

    Test edge cases:
    - Empty text -> ALLOW
    - Very long text -> Handle without error
    - Multiple patterns in one text -> First applicable action wins

    Add pytest to requirements.txt.
  </action>
  <verify>
    cd backend && pip install pytest pytest-asyncio
    pytest tests/test_upl_filter.py -v
  </verify>
  <done>All UPL filter tests pass, covering ALLOW, REPLACE, BLOCK, and REFER scenarios</done>
</task>

</tasks>

<verification>
1. `pytest tests/test_upl_filter.py -v` - All tests pass
2. Filter test endpoint returns ALLOW for neutral text
3. Filter test endpoint returns REPLACE for advice with matching clause category
4. Filter test endpoint returns REFER for tax/estate duty mentions
5. Audit logs show upl_filter_activated events for non-ALLOW results
6. Filter handles edge cases (empty text, long text) gracefully
</verification>

<success_criteria>
- UPLFilterService detects legal advice patterns via regex
- Detected advice replaced with approved clause text when available
- Complex scenarios (tax, estate duty, offshore) trigger attorney referral
- All filter activations logged with matched patterns
- Test endpoint allows verification of filter behavior
- Unit tests cover all action types and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-compliance/01-05-SUMMARY.md`
</output>
