---
phase: 01-foundation-compliance
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/services/clause_library.py
  - backend/app/api/clauses.py
  - backend/app/schemas/clause.py
  - backend/scripts/seed_clauses.py
autonomous: true

must_haves:
  truths:
    - "Clause library service retrieves attorney-approved clauses by category"
    - "Only current version clauses are returned by default"
    - "Clause templates support variable substitution"
    - "Sample clauses exist for all will sections"
  artifacts:
    - path: "backend/app/services/clause_library.py"
      provides: "ClauseLibraryService"
      contains: "class ClauseLibraryService"
    - path: "backend/app/api/clauses.py"
      provides: "Clause API endpoints"
      exports: ["router"]
    - path: "backend/scripts/seed_clauses.py"
      provides: "Initial clause seeding"
      contains: "seed_clauses"
  key_links:
    - from: "backend/app/services/clause_library.py"
      to: "backend/app/models/clause.py"
      via: "database query"
      pattern: "select.*Clause"
    - from: "backend/scripts/seed_clauses.py"
      to: "backend/app/models/clause.py"
      via: "clause creation"
      pattern: "Clause\\("
---

<objective>
Create clause library service for retrieving and rendering attorney-approved legal text templates with version control.

Purpose: Single source of truth for all legal text - no freeform AI generation allowed
Output: ClauseLibraryService with template rendering, API endpoints, and seed data
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-compliance/01-RESEARCH.md
@.planning/phases/01-foundation-compliance/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clause library service</name>
  <files>
    backend/app/services/clause_library.py
  </files>
  <action>
    Create ClauseLibraryService:

    **Methods:**
    - get_clause_by_code(code: str, version: int | None = None) -> Clause | None
      - If version is None, return current version (is_current=True)
      - If version specified, return that specific version

    - get_clauses_by_category(category: ClauseCategory, will_type: WillType = WillType.BASIC) -> list[Clause]
      - Return all current clauses in category applicable to will_type
      - Filter by is_current=True and will_type in will_types
      - Order by display_order

    - get_required_clauses(will_type: WillType) -> list[Clause]
      - Return all clauses where is_required=True and applicable to will_type

    - render_clause(clause: Clause, variables: dict) -> str
      - Use Jinja2 to render template_text with variables
      - Validate variables against variables_schema (basic type checking)
      - Return rendered text

    - create_new_version(clause_id: UUID, template_text: str, approved_by: str, approval_notes: str | None = None) -> Clause
      - Set is_current=False on existing clause
      - Create new clause with version+1, previous_version_id=clause_id, is_current=True
      - Copy other fields from original

    Use async/await with SQLModel session. Add Jinja2 to requirements.txt.

    **Dependency function:**
    - get_clause_service(session: AsyncSession = Depends(get_session)) -> ClauseLibraryService
  </action>
  <verify>
    python -c "from app.services.clause_library import ClauseLibraryService; print('ClauseLibraryService OK')"
  </verify>
  <done>ClauseLibraryService with all methods for clause retrieval, filtering, and rendering</done>
</task>

<task type="auto">
  <name>Task 2: Clause API endpoints</name>
  <files>
    backend/app/api/clauses.py
    backend/app/schemas/clause.py
  </files>
  <action>
    Create clause API and schemas:

    **schemas/clause.py:**
    - ClauseResponse: id, code, name, category, version, template_text, variables_schema, will_types, is_required, display_order
    - ClauseRenderRequest: clause_code (str), variables (dict)
    - ClauseRenderResponse: rendered_text (str), clause_code (str), clause_version (int)
    - ClauseListResponse: clauses (list[ClauseResponse]), total (int)

    **api/clauses.py:**
    - GET /api/clauses - List all current clauses, optional filter by category and will_type query params
    - GET /api/clauses/{code} - Get specific clause by code
    - POST /api/clauses/render - Render clause with provided variables, return rendered text

    All endpoints require consent (not in EXEMPT_PATHS).
    Log clause access to audit trail (event_type: clause_accessed, event_category: system).

    Add router to main.py.
  </action>
  <verify>
    curl http://localhost:8000/api/clauses -b cookies.txt
    curl http://localhost:8000/api/clauses/EXEC-01 -b cookies.txt
  </verify>
  <done>Clause endpoints return clauses, require consent, log access</done>
</task>

<task type="auto">
  <name>Task 3: Seed initial attorney-approved clauses</name>
  <files>
    backend/scripts/seed_clauses.py
  </files>
  <action>
    Create seed script with sample clauses:

    **IMPORTANT:** These are PLACEHOLDER clauses for development. Real clauses require attorney approval before Phase 2.

    **Seed clauses for each category:**

    REVOCATION (REVOC-01):
    - "I, {{ testator_name }}, hereby revoke all previous wills and testamentary dispositions made by me."

    EXECUTOR (EXEC-01, EXEC-02):
    - "I appoint {{ executor_name }} (ID: {{ executor_id }}) as the executor of this my will."
    - "Should {{ executor_name }} be unwilling or unable to act, I appoint {{ alternate_executor_name }} as alternate executor."

    BENEFICIARY (BENEF-01, BENEF-02):
    - "I bequeath {{ bequest_description }} to {{ beneficiary_name }} (ID: {{ beneficiary_id }})."
    - "I bequeath the residue of my estate to {{ residuary_beneficiary_name }}."

    GUARDIAN (GUARD-01):
    - "I appoint {{ guardian_name }} as guardian of my minor children. Should {{ guardian_name }} be unwilling or unable to act, I appoint {{ alternate_guardian_name }}."

    WITNESS (WIT-01):
    - "SIGNED at {{ signing_location }} on this {{ signing_date }}."

    Each clause should have:
    - Appropriate variables_schema (JSON schema for variables)
    - will_types: ["basic"] for basic, add "trust"/"usufruct"/"joint" where applicable
    - is_required: True for REVOC-01, EXEC-01, WIT-01
    - approved_by: "PLACEHOLDER - Attorney approval required"
    - approved_at: current datetime

    **Script should:**
    - Check if clauses already exist (by code)
    - Only insert if not exists (idempotent)
    - Print summary of inserted clauses

    Run via: `python -m scripts.seed_clauses`
  </action>
  <verify>
    cd backend && python -m scripts.seed_clauses
    curl http://localhost:8000/api/clauses -b cookies.txt | python -m json.tool | head -30
  </verify>
  <done>Seed script creates placeholder clauses for all categories, API returns them</done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.clause_library import ClauseLibraryService"` works
2. `python -m scripts.seed_clauses` creates clauses without errors
3. Running seed script twice doesn't duplicate clauses
4. GET /api/clauses returns list of seeded clauses
5. GET /api/clauses/EXEC-01 returns executor clause
6. POST /api/clauses/render with variables returns rendered text
7. All clause endpoints require consent (return 403 without cookie)
</verification>

<success_criteria>
- ClauseLibraryService provides clause retrieval, filtering, and Jinja2 rendering
- API endpoints expose clause library with consent requirement
- Seed script creates placeholder clauses for all will sections
- Clauses marked as PLACEHOLDER pending attorney approval
- Version control methods ready for future clause updates
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-compliance/01-04-SUMMARY.md`
</output>
