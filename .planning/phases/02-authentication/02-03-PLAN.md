---
phase: 02-authentication
plan: 03
type: execute
wave: 1
depends_on: ["02-01", "02-02"]
files_modified:
  - frontend/src/services/api.ts
  - frontend/src/hooks/useAuthApi.ts
  - frontend/src/contexts/AuthApiContext.tsx
  - frontend/src/App.tsx
  - frontend/src/features/will/components/WillWizard.tsx
  - frontend/src/features/will/components/WillDashboard.tsx
  - frontend/src/features/will/components/PaymentPage.tsx
  - frontend/src/features/will/components/PaymentReturnPage.tsx
  - frontend/src/features/will/components/DownloadPage.tsx
  - frontend/src/features/will/components/VerificationPage.tsx
  - frontend/src/features/will/components/DocumentPreviewPage.tsx
  - frontend/src/features/will/hooks/useConversation.ts
  - frontend/src/features/will/hooks/useAutoSave.ts
  - frontend/src/features/will/hooks/useVerification.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "API requests from authenticated users include Bearer token"
    - "All will API calls (createWill, getWill, listWills, updateWillSection, etc.) send Authorization header with Clerk session token"
    - "SSE streaming requests (conversation, verification) include Bearer token"
    - "Unauthenticated API client still works for consent/privacy endpoints"
  artifacts:
    - path: "frontend/src/services/api.ts"
      provides: "All will/conversation/verification/payment/download functions inside buildApi factory with tokenGetter"
      contains: "createWill.*tokenGetter"
    - path: "frontend/src/contexts/AuthApiContext.tsx"
      provides: "React Context + Provider + useApi hook for authenticated API client"
      exports: ["AuthApiProvider", "useApi"]
    - path: "frontend/src/hooks/useAuthApi.ts"
      provides: "Hook wiring Clerk getToken into createAuthenticatedApi"
  key_links:
    - from: "frontend/src/contexts/AuthApiContext.tsx"
      to: "frontend/src/hooks/useAuthApi.ts"
      via: "AuthApiProvider calls useAuthApi to get client"
      pattern: "useAuthApi"
    - from: "frontend/src/App.tsx"
      to: "frontend/src/contexts/AuthApiContext.tsx"
      via: "AuthApiProvider wraps authenticated routes inside SignedIn"
      pattern: "AuthApiProvider"
    - from: "frontend/src/features/will/components/WillWizard.tsx"
      to: "frontend/src/contexts/AuthApiContext.tsx"
      via: "useApi() hook replaces direct api function imports"
      pattern: "useApi"
    - from: "frontend/src/features/will/components/WillDashboard.tsx"
      to: "frontend/src/contexts/AuthApiContext.tsx"
      via: "useApi() hook replaces direct api function imports"
      pattern: "useApi"
---

<objective>
Wire Clerk session token into ALL will API calls, closing the critical gap where useAuthApi hook exists but is never used and all will/conversation/verification/payment API functions call request() without tokenGetter.

Purpose: Without this fix, production deployment with CLERK_JWKS_URL set would return 401 on every authenticated API call. This is the only gap preventing Phase 2 from passing verification.

Output: All authenticated API calls send Bearer token; unauthenticated consent/privacy endpoints unchanged.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-authentication/02-01-SUMMARY.md
@.planning/phases/02-authentication/02-02-SUMMARY.md
@.planning/phases/02-authentication/02-VERIFICATION.md

Key files to read before implementation:
@frontend/src/services/api.ts
@frontend/src/hooks/useAuthApi.ts
@frontend/src/App.tsx
@frontend/src/features/will/components/WillWizard.tsx
@frontend/src/features/will/components/WillDashboard.tsx
@frontend/src/features/will/hooks/useConversation.ts
@frontend/src/features/will/hooks/useAutoSave.ts
@frontend/src/features/will/hooks/useVerification.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Move all will API functions into buildApi factory and create AuthApiContext</name>
  <files>
    frontend/src/services/api.ts
    frontend/src/contexts/AuthApiContext.tsx
    frontend/src/hooks/useAuthApi.ts
  </files>
  <action>
    **Part A — Consolidate all API functions into buildApi (frontend/src/services/api.ts)**

    Move ALL standalone will/conversation/verification/payment/download functions into the existing `buildApi(tokenGetter?)` factory so they become methods on `ApiClient`. This means every API call automatically gets the Bearer token when a tokenGetter is provided.

    Functions to move inside `buildApi`:
    - `createWill(willType?)` — POST /wills
    - `getWill(willId)` — GET /wills/{willId}
    - `listWills()` — GET /wills
    - `updateWillSection(willId, section, data)` — PATCH /wills/{willId}/sections/{section}
    - `markSectionComplete(willId, section)` — POST /wills/{willId}/sections/{section}/complete
    - `getConversationHistory(willId, section)` — GET /conversation/{willId}/{section}
    - `extractConversationData(willId, section)` — POST /conversation/{willId}/{section}/extract
    - `getVerificationResult(willId)` — GET /wills/{willId}/verification
    - `acknowledgeWarnings(willId, warningCodes)` — POST /wills/{willId}/acknowledge-warnings
    - `generatePreview(willId)` — POST /wills/{willId}/preview (NOTE: this uses raw fetch for blob response — refactor to use a requestBlob helper that also injects tokenGetter)
    - `initiatePayment(willId)` — POST /payment/initiate
    - `getPaymentStatus(paymentId)` — GET /payment/{paymentId}/status
    - `downloadWill(token)` — GET /download/{token} (blob response — same requestBlob pattern)
    - `updateCurrentSection(willId, section)` — PATCH /wills/{willId}/current-section
    - `regenerateWill(willId)` — POST /wills/{willId}/regenerate

    Add a private `requestBlob` helper inside buildApi (similar to `request` but returns Blob instead of JSON) that also injects the Bearer token. Use it for `generatePreview` and `downloadWill`.

    Keep the existing `api` export (`const api = buildApi()`) for unauthenticated consent/privacy endpoints.

    Remove all the standalone function exports (createWill, getWill, etc.) — they will be accessed as methods on the ApiClient instance.

    Update the `ApiClient` type to include all new methods.

    **Part B — Create AuthApiContext (frontend/src/contexts/AuthApiContext.tsx)**

    Create a React Context that provides the authenticated ApiClient globally to all components inside the auth gate:

    ```typescript
    import { createContext, useContext, type ReactNode } from 'react'
    import { useAuthApi } from '../hooks/useAuthApi'
    import type { ApiClient } from '../services/api'

    const AuthApiContext = createContext<ApiClient | null>(null)

    export function AuthApiProvider({ children }: { children: ReactNode }) {
      const api = useAuthApi()
      return (
        <AuthApiContext.Provider value={api}>
          {children}
        </AuthApiContext.Provider>
      )
    }

    export function useApi(): ApiClient {
      const ctx = useContext(AuthApiContext)
      if (!ctx) {
        throw new Error('useApi must be used within AuthApiProvider')
      }
      return ctx
    }
    ```

    **Part C — Keep useAuthApi as-is (frontend/src/hooks/useAuthApi.ts)**

    No changes needed to useAuthApi.ts — it already correctly creates the authenticated API client. The AuthApiProvider in Part B will use it.

    **IMPORTANT constraints:**
    - Do NOT break the existing `api` export used by ConsentProvider, PrivacyPolicy, InfoOfficerContact — those are unauthenticated and must keep working
    - Preserve all existing type exports (WillResponse, ConversationHistoryMessage, etc.)
    - The `snakeToCamel` utility must remain exported (used by useWillStore)
  </action>
  <verify>
    Run `npx tsc --noEmit` from frontend/ directory — no type errors.
    Verify `api` export still exists for unauthenticated callers.
    Verify `ApiClient` type includes all will/conversation/verification methods.
    Verify `AuthApiProvider` and `useApi` are exported from contexts/AuthApiContext.tsx.
  </verify>
  <done>
    All will API functions are methods on ApiClient (with tokenGetter injection).
    AuthApiContext provides authenticated client to React tree.
    Unauthenticated `api` export unchanged for consent/privacy endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire AuthApiProvider into App.tsx and update all call sites to use useApi()</name>
  <files>
    frontend/src/App.tsx
    frontend/src/features/will/components/WillWizard.tsx
    frontend/src/features/will/components/WillDashboard.tsx
    frontend/src/features/will/components/PaymentPage.tsx
    frontend/src/features/will/components/PaymentReturnPage.tsx
    frontend/src/features/will/components/DownloadPage.tsx
    frontend/src/features/will/components/VerificationPage.tsx
    frontend/src/features/will/components/DocumentPreviewPage.tsx
    frontend/src/features/will/hooks/useConversation.ts
    frontend/src/features/will/hooks/useAutoSave.ts
    frontend/src/features/will/hooks/useVerification.ts
  </files>
  <action>
    **Part A — Add AuthApiProvider to App.tsx**

    Wrap authenticated content with AuthApiProvider inside AuthGatedContent, between SignedIn and ConsentProvider:

    ```tsx
    import { AuthApiProvider } from './contexts/AuthApiContext'

    function AuthGatedContent({ children }: { children: React.ReactNode }) {
      return (
        <>
          <SignedOut>
            <LandingPage />
          </SignedOut>
          <SignedIn>
            <AuthApiProvider>
              <ConsentProvider>
                <ConsentModal />
                {children}
              </ConsentProvider>
            </AuthApiProvider>
          </SignedIn>
        </>
      )
    }
    ```

    AuthApiProvider MUST be inside SignedIn (so useAuth() from Clerk is available) and OUTSIDE ConsentProvider (so consent API calls can also be authenticated if needed later).

    **Part B — Update all component call sites**

    For each component that directly imports standalone API functions, replace with `useApi()`:

    1. **WillWizard.tsx** — The biggest change. Currently imports createWill, getWill, updateWillSection, extractConversationData, markSectionComplete, updateCurrentSection from api.ts.
       - Add `const api = useApi()` at the top of WillWizard component
       - Replace all `createWill(...)` with `api.createWill(...)`
       - Replace all `getWill(...)` with `api.getWill(...)`
       - Replace all `updateWillSection(...)` with `api.updateWillSection(...)`
       - Replace all `extractConversationData(...)` with `api.extractConversationData(...)`
       - Replace all `markSectionCompleteApi(...)` with `api.markSectionComplete(...)`
       - Replace all `updateCurrentSection(...)` with `api.updateCurrentSection(...)`
       - Remove the old imports from '../../../services/api.ts' (keep only type imports like WillSection)

    2. **WillDashboard.tsx** — imports listWills, getWill.
       - Add `const api = useApi()`
       - Replace `queryFn: listWills` with `queryFn: () => api.listWills()`
       - Replace `getWill(willId)` with `api.getWill(willId)`
       - Remove old function imports (keep WillResponse type import)

    3. **PaymentPage.tsx** — imports initiatePayment.
       - Add `const api = useApi()`
       - Replace `initiatePayment(willId)` with `api.initiatePayment(willId)`
       - Remove old function import (keep PaymentInitiateResponse type import)

    4. **PaymentReturnPage.tsx** — imports getPaymentStatus.
       - Add `const api = useApi()`
       - Replace `getPaymentStatus(paymentId)` with `api.getPaymentStatus(paymentId)`
       - Remove old function import

    5. **DownloadPage.tsx** — imports downloadWill.
       - Add `const api = useApi()`
       - Replace `downloadWill(token)` with `api.downloadWill(token)`
       - Remove old function import

    6. **VerificationPage.tsx** — imports acknowledgeWarnings.
       - Add `const api = useApi()`
       - Replace `acknowledgeWarnings(...)` with `api.acknowledgeWarnings(...)`
       - Remove old function import

    7. **DocumentPreviewPage.tsx** — imports generatePreview, regenerateWill.
       - Add `const api = useApi()`
       - Replace `generatePreview(willId)` with `api.generatePreview(willId)`
       - Replace `regenerateWill(willId)` with `api.regenerateWill(willId)`
       - Remove old function imports

    **Part C — Update hooks that use API functions**

    These hooks are called inside React components, so they can accept the API client as a parameter or use useApi() directly.

    8. **useConversation.ts** — imports getConversationHistory and uses raw fetch for SSE streaming.
       - Accept `api: ApiClient` as parameter in the options object: `{ section, willContext, willId, api }`
       - Replace `getConversationHistory(willId!, section)` with `api.getConversationHistory(willId!, section)`
       - For the SSE streaming fetch call (POST /api/conversation/stream): The hook uses raw `fetch()` directly. Add a `getToken` parameter to options as well (type `() => Promise<string | null>`), and inject the Bearer token into the fetch headers. The caller (ChatSection.tsx and similar) will pass `api` and a `getToken` function.
       - ALTERNATIVELY (simpler): Add a `streamToken` method on ApiClient that just returns the token, so hooks can call `const token = await api.getStreamToken()` and inject it themselves. This avoids passing getToken through every hook.
       - PREFERRED APPROACH: Add a `getToken(): Promise<string | null>` method to ApiClient (inside buildApi, it just calls tokenGetter). Hooks use `api.getToken()` to inject Bearer token into their raw fetch calls. This keeps the pattern uniform.
       - Update ChatSection.tsx to pass `api` when calling useConversation.

    9. **useAutoSave.ts** — imports updateWillSection.
       - Accept `api: ApiClient` as additional parameter
       - Replace `updateWillSection(willId, section, dataRef.current)` with `api.updateWillSection(willId, section, dataRef.current)` (both occurrences)
       - Update callers (PersonalForm, MaritalForm, or wherever useAutoSave is called) to pass `api`

    10. **useVerification.ts** — uses raw fetch for SSE streaming.
        - Accept `api: ApiClient` as parameter alongside willId
        - Use `api.getToken()` to inject Bearer token into the raw fetch headers
        - Update VerificationPage.tsx to pass `api` when calling useVerification

    **For all hook updates:** Import `type { ApiClient }` from '../../../services/api' (or wherever needed).

    **IMPORTANT:** After all changes, grep the entire `frontend/src` directory for any remaining direct imports of the now-removed standalone functions (createWill, getWill, listWills, updateWillSection, markSectionComplete, getConversationHistory, extractConversationData, getVerificationResult, acknowledgeWarnings, generatePreview, initiatePayment, getPaymentStatus, downloadWill, updateCurrentSection, regenerateWill). There should be ZERO remaining imports of these as standalone functions.
  </action>
  <verify>
    Run `npx tsc --noEmit` from frontend/ directory — no type errors.
    Run `grep -rn "import.*{.*createWill\|getWill\|listWills\|updateWillSection\|extractConversationData\|markSectionComplete\|getConversationHistory\|getVerificationResult\|acknowledgeWarnings\|generatePreview\|initiatePayment\|getPaymentStatus\|downloadWill\|updateCurrentSection\|regenerateWill.*}.*from.*services/api" frontend/src/` — should return ZERO matches (only type imports allowed).
    Run `grep -rn "useApi\|useAuthApi" frontend/src/` — should show useApi used in all will-related components and hooks.
    Run `grep -rn "AuthApiProvider" frontend/src/App.tsx` — should show provider wrapping authenticated content.
    Run the dev server: `cd frontend && npm run dev` — app compiles without errors.
  </verify>
  <done>
    All authenticated API calls flow through useApi() context which injects Clerk Bearer token.
    SSE streaming hooks (useConversation, useVerification) inject Bearer token via api.getToken().
    No standalone will API function imports remain in components/hooks.
    AuthApiProvider wraps authenticated routes in App.tsx.
    Unauthenticated consent/privacy endpoints continue working via the `api` export.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. No standalone will API function imports remain (only type imports)
3. All will-related components use `useApi()` hook
4. SSE streaming requests include Authorization header
5. Dev server compiles and runs without errors
6. Consent/privacy endpoints still work without authentication
</verification>

<success_criteria>
- Every API call to a protected endpoint includes `Authorization: Bearer <clerk_token>` header
- The `useAuthApi` hook is no longer orphaned — it's consumed by AuthApiProvider
- AuthApiProvider is in the React tree wrapping all authenticated routes
- All 16 will API functions are methods on ApiClient, not standalone exports
- Zero regressions: consent, privacy-policy, info-officer endpoints remain unauthenticated
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-03-SUMMARY.md`
</output>
