---
phase: 02-authentication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/config.py
  - backend/app/middleware/clerk_auth.py
  - backend/app/models/user.py
  - backend/app/models/__init__.py
  - backend/app/services/user_service.py
  - backend/app/main.py
  - backend/app/middleware/popia_consent.py
  - backend/requirements.txt
autonomous: true

must_haves:
  truths:
    - "API requests without valid Clerk session token receive 401"
    - "API requests with valid Clerk session token pass through to handlers"
    - "First authenticated API call creates a local user record"
    - "Subsequent calls reuse existing local user record"
    - "Consent-only endpoints still work without Clerk auth"
    - "Health, docs, consent, privacy endpoints remain exempt from auth"
    - "Audit logs include local user_id when user is authenticated"
  artifacts:
    - path: "backend/app/middleware/clerk_auth.py"
      provides: "Clerk session JWT verification via JWKS"
      contains: "ClerkAuthMiddleware"
      min_lines: 40
    - path: "backend/app/models/user.py"
      provides: "User SQLModel linked by clerk_user_id"
      contains: "clerk_user_id"
    - path: "backend/app/services/user_service.py"
      provides: "Lazy user creation and lookup"
      contains: "get_or_create_user"
    - path: "backend/app/config.py"
      provides: "CLERK_JWKS_URL setting"
      contains: "CLERK_JWKS_URL"
    - path: "backend/app/main.py"
      provides: "Updated middleware stack with Clerk auth"
      contains: "ClerkAuthMiddleware"
  key_links:
    - from: "backend/app/middleware/clerk_auth.py"
      to: "backend/app/config.py"
      via: "CLERK_JWKS_URL for key fetching"
      pattern: "settings\\.CLERK_JWKS_URL"
    - from: "backend/app/middleware/clerk_auth.py"
      to: "backend/app/services/user_service.py"
      via: "Lazy user creation on valid auth"
      pattern: "get_or_create_user|UserService"
    - from: "backend/app/main.py"
      to: "backend/app/middleware/clerk_auth.py"
      via: "Middleware registration"
      pattern: "ClerkAuthMiddleware"

user_setup:
  - service: clerk
    why: "Backend needs JWKS URL to verify Clerk session tokens"
    env_vars:
      - name: CLERK_JWKS_URL
        source: "Clerk Dashboard -> API Keys -> Advanced -> JWKS URL (format: https://{instance}.clerk.accounts.dev/.well-known/jwks.json)"
---

<objective>
Add Clerk session verification to the FastAPI backend. Requests with valid Clerk JWTs are authenticated; the user's local record is lazily created on first call. The existing POPIA consent gate stays in place, creating a dual-gate: Clerk auth + POPIA consent both required for will-related endpoints.

Purpose: Backend half of AUTH-01 through AUTH-04 -- verify that the user who registered/logged in via Clerk on the frontend has a valid session before accessing protected endpoints.
Output: Clerk auth middleware, User model, user service, updated middleware stack.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/app/main.py
@backend/app/config.py
@backend/app/middleware/popia_consent.py
@backend/app/middleware/audit.py
@backend/app/models/__init__.py
@backend/app/database.py
@backend/app/services/audit_service.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Clerk auth middleware with JWKS verification</name>
  <files>backend/app/config.py, backend/app/middleware/clerk_auth.py, backend/requirements.txt</files>
  <action>
    **requirements.txt:**
    1. Add `PyJWT[crypto]>=2.8.0` for RS256 JWT verification (Clerk uses RS256, not HS256).
       Note: python-jose is already installed for POPIA consent (HS256). PyJWT handles Clerk's RS256 tokens with JWKS.

    **config.py:**
    2. Add `CLERK_JWKS_URL: str = ""` to Settings class.
       This URL comes from the Clerk Dashboard (format: `https://{instance}.clerk.accounts.dev/.well-known/jwks.json`).
       Empty default means Clerk auth is disabled in dev if not configured (fail gracefully).

    **middleware/clerk_auth.py:**
    3. Create `ClerkAuthMiddleware` (BaseHTTPMiddleware pattern matching existing middleware):

       Exempt paths (no auth required) -- same as POPIA exempt paths PLUS:
       - `/api/health`, `/api/consent`, `/api/consent/status`, `/api/consent/withdraw`
       - `/api/privacy-policy`, `/api/info-officer`, `/api/data-request`
       - `/docs`, `/openapi.json`, `/redoc`
       - `/static/`, `/favicon` prefixes
       Per user decision: "All pages except landing/marketing require Clerk auth"
       These paths are the informational/consent paths that must remain accessible.

       JWKS key caching:
       - On first request (or cache miss), fetch JWKS from `settings.CLERK_JWKS_URL` using `httpx.AsyncClient`
       - Parse the JWKS JSON and build `PyJWT`-compatible keys using `jwt.PyJWKClient` or manual RSA key construction
       - Cache the JWKS keys in memory with a TTL of 1 hour (simple timestamp check)
       - If CLERK_JWKS_URL is empty string, skip auth entirely (dev mode without Clerk)

       Token verification:
       - Extract `Authorization: Bearer {token}` header
       - If no header, return 401 `{"error": "authentication_required", "message": "Valid Clerk session required."}`
       - Decode token using PyJWT with RS256 algorithm and the cached JWKS public key
       - Extract `sub` claim (this is the Clerk user ID, e.g., `user_2x...`)
       - Store `clerk_user_id` in `request.state.clerk_user_id` for downstream use
       - On verification failure (expired, invalid signature, etc.), return 401

       Use `PyJWT`'s `jwt.PyJWKClient` for JWKS fetching/caching -- it handles key rotation automatically:
       ```python
       jwks_client = jwt.PyJWKClient(settings.CLERK_JWKS_URL, cache_keys=True, lifespan=3600)
       signing_key = jwks_client.get_signing_key_from_jwt(token)
       payload = jwt.decode(token, signing_key.key, algorithms=["RS256"])
       ```

       Error handling:
       - If JWKS fetch fails, log error, return 503 (temporary, retry later)
       - If token is expired, return 401 with clear message
       - If token signature invalid, return 401

    IMPORTANT per user decision:
    - No Clerk Python SDK needed -- just JWT verification via JWKS
    - Backend verifies the session JWT that Clerk's frontend SDK sends
  </action>
  <verify>
    `grep -q "ClerkAuthMiddleware" backend/app/middleware/clerk_auth.py` confirms middleware exists.
    `grep -q "CLERK_JWKS_URL" backend/app/config.py` confirms config setting.
    `grep -q "PyJWT" backend/requirements.txt` confirms dependency added.
    `cd backend && python -c "from app.middleware.clerk_auth import ClerkAuthMiddleware"` imports without error.
  </verify>
  <done>
    ClerkAuthMiddleware verifies Clerk session JWTs using JWKS public keys.
    Exempt paths pass through without auth.
    Clerk user ID stored in request.state for downstream use.
    JWKS keys cached with automatic rotation handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: User model, lazy creation service, and middleware stack wiring</name>
  <files>backend/app/models/user.py, backend/app/models/__init__.py, backend/app/services/user_service.py, backend/app/main.py, backend/app/middleware/popia_consent.py</files>
  <action>
    **models/user.py:**
    1. Create User SQLModel:
       ```
       id: uuid (PK, default uuid4)
       clerk_user_id: str (unique, indexed, NOT NULL) -- Clerk's external user ID
       email: str (NOT NULL) -- synced from Clerk on creation
       created_at: datetime (server_default=now)
       updated_at: datetime (server_default=now, onupdate=now)
       ```
       Per user decision: Store ONLY these fields. All profile data stays in Clerk.
       Use `SQLModel` with `table=True` following existing model patterns (see consent.py, clause.py).

    **models/__init__.py:**
    2. Add `User` to imports and `__all__` list.

    **services/user_service.py:**
    3. Create `UserService` following existing service pattern (see audit_service.py):
       - `get_or_create_user(clerk_user_id: str, email: str) -> User`
         - Query by `clerk_user_id`
         - If exists, return existing record
         - If not, create new User with clerk_user_id and email, return it
         - Per user decision: "Local user record created on first authenticated API call (lazy creation)"
       - Support both injected session (via DI) and standalone session creation (matching AuditService pattern)
       - This is called from the Clerk auth middleware after successful JWT verification

    **middleware/clerk_auth.py (update from Task 1):**
    4. After successful JWT verification, call `UserService.get_or_create_user()`:
       - Extract `clerk_user_id` from JWT `sub` claim
       - Extract `email` from JWT claims (Clerk includes email in session tokens if configured, or use a placeholder and update later)
       - If email not in JWT claims, use empty string -- it will be updated on next call
       - Store the local `User.id` (UUID) in `request.state.user_id` for audit logging
       - Store `clerk_user_id` in `request.state.clerk_user_id`

    **main.py middleware stack:**
    5. Update middleware registration order (bottom-to-top, last added runs first):
       ```python
       # 1. CORS (outermost)
       app.add_middleware(CORSMiddleware, ...)
       # 2. Clerk auth gate (verifies session JWT)
       app.add_middleware(ClerkAuthMiddleware)
       # 3. POPIA consent gate (verifies consent cookie)
       app.add_middleware(POPIAConsentMiddleware)
       # 4. Audit trail (logs requests)
       app.add_middleware(AuditMiddleware)
       ```

       Execution order (first to run): Audit -> POPIA -> Clerk -> CORS
       This means:
       - Audit runs on everything (including auth failures -- useful for security logging)
       - POPIA checks consent (for non-exempt paths)
       - Clerk checks authentication (for non-exempt paths)
       Both gates must pass for protected endpoints (dual-gate per user decision).

    **middleware/popia_consent.py:**
    6. Add Clerk auth-related paths to EXEMPT_PATHS if any new paths are needed.
       Currently the exempt paths should cover all public endpoints.
       No changes expected unless new auth-specific API routes are added.

    **Import the router:**
    7. No new API routes needed in this phase -- auth is handled entirely by middleware.
       The User model is created lazily via middleware, not via an explicit registration endpoint.

    **Database migration:**
    8. Generate Alembic migration for the new `user` table:
       `cd backend && alembic revision --autogenerate -m "add user table for clerk auth"`
       Then: `alembic upgrade head`
  </action>
  <verify>
    `cd backend && python -c "from app.models.user import User; print(User.__tablename__)"` prints table name.
    `cd backend && python -c "from app.services.user_service import UserService"` imports without error.
    `cd backend && python -c "from app.main import app; print([m.cls.__name__ for m in app.user_middleware])"` shows ClerkAuthMiddleware in stack.
    `cd backend && alembic check` shows no pending migrations (migration applied).
    `grep -q "ClerkAuthMiddleware" backend/app/main.py` confirms middleware registered.
  </verify>
  <done>
    User model with clerk_user_id exists and has migration applied.
    UserService provides get_or_create_user for lazy record creation.
    Middleware stack enforces dual gate: Clerk auth + POPIA consent.
    Audit middleware runs on all requests including auth failures.
    Protected endpoints require both valid Clerk session AND POPIA consent.
    Exempt endpoints (health, consent, privacy, docs) accessible without either gate.
  </done>
</task>

</tasks>

<verification>
- Backend starts without errors: `cd backend && uvicorn app.main:app`
- `curl http://localhost:8000/api/health` returns 200 (exempt from auth)
- `curl http://localhost:8000/api/consent/status` returns 200 (exempt from auth)
- `curl http://localhost:8000/api/clauses` without Bearer token returns 401
- `curl -H "Authorization: Bearer INVALID" http://localhost:8000/api/clauses` returns 401
- User table exists in database with clerk_user_id column
- Middleware stack order: CORS > ClerkAuth > POPIA > Audit
</verification>

<success_criteria>
- Clerk JWT verification works via JWKS (RS256)
- JWKS keys cached with 1-hour TTL
- Unauthenticated requests to protected endpoints return 401
- Exempt endpoints accessible without authentication
- User model stores only id, clerk_user_id, email, created_at, updated_at
- Lazy user creation on first authenticated call
- Dual gate enforced: both Clerk auth and POPIA consent required for will endpoints
- Alembic migration for user table applied
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication/02-02-SUMMARY.md`
</output>
