---
phase: 05-ai-verification
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - backend/app/services/verification_service.py
  - backend/app/api/verification.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /api/wills/{will_id}/verify streams SSE progress events and returns verification result"
    - "GET /api/wills/{will_id}/verification returns the last saved verification result"
    - "POST /api/wills/{will_id}/acknowledge-warnings saves acknowledged warning codes"
    - "If Gemini is unavailable, verification falls back to OpenAI"
    - "Verification result is persisted to Will model verification_result JSONB column"
    - "Will status transitions to 'verified' only when no blocking errors remain"
  artifacts:
    - path: "backend/app/services/verification_service.py"
      provides: "Orchestrates verification flow: Gemini call, fallback, SSE events, DB persistence"
      min_lines: 80
    - path: "backend/app/api/verification.py"
      provides: "Three verification endpoints (verify SSE, get result, acknowledge warnings)"
      min_lines: 50
  key_links:
    - from: "backend/app/services/verification_service.py"
      to: "backend/app/services/gemini_service.py"
      via: "GeminiService.verify() call"
      pattern: "gemini.*verify|GeminiService"
    - from: "backend/app/services/verification_service.py"
      to: "backend/app/schemas/verification.py"
      via: "VerificationResult as response schema"
      pattern: "VerificationResult"
    - from: "backend/app/api/verification.py"
      to: "backend/app/services/verification_service.py"
      via: "DI injection of VerificationService"
      pattern: "VerificationService|get_verification_service"
    - from: "backend/app/main.py"
      to: "backend/app/api/verification.py"
      via: "Router registration"
      pattern: "verification"
---

<objective>
Build the verification service (Gemini orchestration + OpenAI fallback + SSE progress) and REST/SSE API endpoints.

Purpose: Core verification logic -- calls Gemini with will data, handles fallback to OpenAI, streams progress via SSE, persists results, gates PDF generation.
Output: VerificationService, three API endpoints, router registered in main.py.
</objective>

<execution_context>
@/home/laudes/.claude/get-shit-done/workflows/execute-plan.md
@/home/laudes/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ai-verification/05-01-SUMMARY.md
@.planning/phases/05-ai-verification/05-02-SUMMARY.md
@backend/app/services/conversation_service.py
@backend/app/api/conversation.py
@backend/app/services/gemini_service.py
@backend/app/schemas/verification.py
@backend/app/prompts/verification.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verification service with Gemini + OpenAI fallback</name>
  <files>backend/app/services/verification_service.py</files>
  <action>
    Create backend/app/services/verification_service.py with VerificationService class:

    **Constructor:**
    - Takes `session: AsyncSession` (DI injected, same pattern as ConversationService)
    - Creates GeminiService instance from settings (GEMINI_API_KEY, GEMINI_MODEL)
    - Creates OpenAI fallback client from settings (OPENAI_API_KEY, OPENAI_MODEL)

    **Method: `async def run_verification(self, will_id: UUID, user_id: UUID) -> AsyncGenerator[dict, None]`**
    This is the main SSE generator. Yields dicts that become SSE events.

    Flow:
    1. Load Will from DB (enforce user ownership, 404 if not found)
    2. Collect all will JSONB data into a single dict:
       ```python
       will_data = {
           "testator": will.testator,
           "marital": will.marital,
           "beneficiaries": will.beneficiaries,
           "assets": will.assets,
           "guardians": will.guardians,
           "executor": will.executor,
           "bequests": will.bequests,
           "residue": will.residue,
           "trust_provisions": will.trust_provisions,
           "usufruct": will.usufruct,
           "business_assets": will.business_assets,
           "joint_will": will.joint_will,
           "scenarios": will.scenarios,
           "will_type": will.will_type,
           "sections_complete": will.sections_complete,
       }
       ```
    3. Yield `{"event": "check", "data": {"step": "collecting_data", "message": "Collecting will data..."}}` -- progress event
    4. Build verification prompt: `build_verification_prompt(will_data)`
    5. Yield `{"event": "check", "data": {"step": "verifying", "message": "Verifying with AI..."}}`
    6. Try Gemini first:
       - Call `gemini_service.verify(prompt, VerificationResult)`
       - If Gemini raises exception -> yield `{"event": "check", "data": {"step": "fallback", "message": "Switching to backup verification..."}}` -> fall back to OpenAI
    7. OpenAI fallback:
       - Use `openai.beta.chat.completions.parse()` with the same prompt and `response_format=VerificationResult`
       - Wrap in try/except -- if both fail, yield error event and return
    8. Yield `{"event": "check", "data": {"step": "analyzing_results", "message": "Analyzing results..."}}`
    9. Process per-section results: for each section in result.sections, yield:
       `{"event": "section_result", "data": {"section": section.section, "status": section.status, "issue_count": len(section.issues)}}`
    10. Persist result: Update will.verification_result = result.model_dump(), will.verified_at = now(UTC)
    11. If no blocking errors (no issues with severity "error"): update will.status = "verified"
    12. Commit to DB
    13. Yield `{"event": "done", "data": result.model_dump()}` -- final event with full result

    **Method: `async def get_verification_result(self, will_id: UUID, user_id: UUID) -> dict | None`**
    - Load will, enforce ownership, return will.verification_result (or None if not verified yet)

    **Method: `async def acknowledge_warnings(self, will_id: UUID, user_id: UUID, warning_codes: list[str]) -> dict`**
    - Load will, enforce ownership
    - Merge warning_codes into will.acknowledged_warnings (deduplicate)
    - Check if can_proceed: no unacknowledged errors remain
    - Commit and return {"acknowledged": will.acknowledged_warnings, "can_proceed": can_proceed}

    **Factory: `async def get_verification_service(session: AsyncSession = Depends(get_session)) -> VerificationService`**
    - Returns VerificationService(session) -- standard DI pattern

    Follow conversation_service.py patterns: async session DI, user ownership checks, fire-and-forget audit (optional), logging.
  </action>
  <verify>
    cd backend && python -c "from app.services.verification_service import VerificationService, get_verification_service; print('VerificationService imported OK')"
  </verify>
  <done>
    VerificationService with run_verification (SSE generator), get_verification_result, acknowledge_warnings methods. Gemini-first with OpenAI fallback. Results persisted to Will model. Status transitions to "verified" on success.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verification API endpoints and router registration</name>
  <files>
    backend/app/api/verification.py
    backend/app/main.py
  </files>
  <action>
    1. Create backend/app/api/verification.py with three endpoints:

    **POST `/api/wills/{will_id}/verify`** -- SSE streaming verification
    - Extract user_id from request.state (same pattern as conversation.py _extract_user_id)
    - Call verification_service.run_verification(will_id, user_id)
    - Return EventSourceResponse wrapping the async generator
    - SSE events: "check" (progress), "section_result" (per-section), "done" (full result), "error"
    - Use `sse_starlette.sse.EventSourceResponse`

    **GET `/api/wills/{will_id}/verification`** -- Get last result
    - Extract user_id
    - Call get_verification_result
    - Return VerificationResponse (or 404 if no verification yet)
    - Include has_blocking_errors computed from result
    - Include acknowledged_warnings from Will model

    **POST `/api/wills/{will_id}/acknowledge-warnings`** -- Acknowledge warnings
    - Accept AcknowledgeWarningsRequest body
    - Call acknowledge_warnings
    - Return AcknowledgeWarningsResponse

    Router: `APIRouter(prefix="/api/wills", tags=["verification"])`
    (Shares /api/wills prefix with will.py but uses different sub-paths)

    Follow the same patterns as conversation.py: _extract_user_id helper, Depends for service DI, proper error handling.

    2. Register the router in backend/app/main.py:
    - Add import: `from app.api import verification`
    - Add router: `app.include_router(verification.router)` alongside existing routers
  </action>
  <verify>
    cd backend && python -c "
from app.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
assert any('verify' in r for r in routes), f'verify route missing: {routes}'
print('Verification routes registered')
"
  </verify>
  <done>
    Three verification endpoints (SSE verify, GET result, POST acknowledge) registered in app. SSE streams progress events matching existing dual-event pattern. All endpoints enforce user ownership.
  </done>
</task>

</tasks>

<verification>
1. VerificationService imports without errors
2. All three endpoints are registered in the FastAPI app
3. SSE endpoint returns EventSourceResponse
4. Verification result is persisted to DB
5. OpenAI fallback activates when Gemini is unavailable
6. Will status transitions to "verified" when no errors
</verification>

<success_criteria>
- POST /api/wills/{id}/verify streams SSE check/section_result/done events
- GET /api/wills/{id}/verification returns last saved result
- POST /api/wills/{id}/acknowledge-warnings persists acknowledged codes
- Gemini-first with OpenAI fallback on failure
- Will.verification_result JSONB populated after verification
- Will.status = "verified" when no blocking errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-ai-verification/05-03-SUMMARY.md`
</output>
